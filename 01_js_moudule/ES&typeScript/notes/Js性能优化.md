### 内存管理
- 内存管理： 开发者主动申请空间，使用空间， 释放空间
- 管理内存： 申请 - 使用 - 释放
```javascript
// 申请空间
let obj = {}

// 使用
obj.name = 'jack',

// 释放
obj = null
```





### GC算法
1. 引用计数算法
  - 优点：发现垃圾时立即回收，最大程度减少程序卡顿
  - 缺点： 无法回收循环引用对象、 资源消耗大


2. 标记清除算法
  - 核心思想： 分标记和清除两个阶段
    - 标记： 遍历所有的对象标记活动对象
    - 清除： 遍历所有对象清除没有标记的对象
    - 回收相应的空间
  - 优点： 可以回收循环引用的对象空间
  - 缺点： 容易产生碎片化空间，浪费空间


3. 标记整理算法(标记清除增强)
  - 标记阶段的操作和标记清除一致
  - 清除阶段会先执行整理， 移动对象在内存中的位置，可以在地址上产生连续
  - 优点： 解决标记清除空间碎片化的问题，可以最大化利用空间内存中释放出来的空间
  - 缺点： 不会立即回收垃圾对象






### v8垃圾回收
1. 认识v8
  - 主流的js执行引擎
  - 采用即时编译
  - 内存设限
2. v8垃圾回收策略
  - 采用分代回收思想：内存分为新生代和老生代，针对不同对象采用不同算法
  - v8中常见的GC算法：分代回收、空间复制、标记清除、标记整理、标记增量

3. v8内存分配
  - v8内存空间一份为二
  - 新生代回收
    - 新生代： 存活时间较短的对象； 小空间用于存储新生代对象(32M | 16M)
    - 回收过程采用复制算法 + 标记整理： 新生代内存区分为From和TO两个等大的空间，From为使用空间，To为空闲空间；
    - 活动对象存储在From空间，标记整理后将活动对象拷贝至To空间, From与To交换空间完成释放
    - 拷贝过程可能出现晋升：一轮GC还存活的新生代需要晋升； To空间的使用率超过25%
  - 老生代回收
    - 老生代：存活时间较长的数据，例如闭包、全局变量， 64位操作系统 1.4G； 32位操作系统700M
    - 主要采用标记清除 + 标记整理 + 增量标记的算法： 使用标记清除按成垃圾空间的回收，采用标记整理进行空间优化(当新生代需要晋升至老生代，出现空间不足时)，采用增量标记进行效率优化
  - 新生代区域空间换时间； 老生代区域不适合复制算法



### Performance
1. 可以对内存进行监控
2. 内存问题的表现
  - 页面出现延迟加载或经常性暂停
  - 页面出现糟糕的性能
  - 页面的性能随时间延长越来越差
3. 监控内存的方式
  - 内存泄漏： 内存持续升高
  - 内存膨胀: 多数设备上都存在性能问题
  - 频繁垃圾回收： 通过内存变化图进行分析
  - 方式： 浏览器任务管理器、 Timeline时序图记录、 对快照查找分离DOM、判断是否存在频繁的垃圾回收



### 代码优化
1. 慎用全局变量
  - 全局变量定义在全局执行上下文，是所有作用域的顶端。 (查找执行消耗较大)
  - 全局执行上下文一直存在于上下文执行栈中，知道程序退出。(不利用GC)
  - 全局变量容易被污染
  - 缓存全局变量
2. 通过原型对象添加附加方法
3. 慎用闭包： 使用不当容易造成内存泄漏
4. 避免属性访问方法的使用
5. for循环
  - 将数组长度存到一个变量中， 减少循环体活动
6. 减少判断层级
7. 减少作用域链查找层级
8. 减少数据读取次数
9. 字面量执行效率相较构造式更高
10. 减少声明及语句数